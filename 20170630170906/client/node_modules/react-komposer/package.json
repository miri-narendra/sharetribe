{
  "_args": [
    [
      {
        "raw": "react-komposer@https://registry.npmjs.org/react-komposer/-/react-komposer-1.8.0.tgz",
        "scope": null,
        "escapedName": "react-komposer",
        "name": "react-komposer",
        "rawSpec": "https://registry.npmjs.org/react-komposer/-/react-komposer-1.8.0.tgz",
        "spec": "https://registry.npmjs.org/react-komposer/-/react-komposer-1.8.0.tgz",
        "type": "remote"
      },
      "/home/rails/production/releases/20170630170906/client"
    ]
  ],
  "_from": "react-komposer@>=1.8.0 <2.0.0",
  "_id": "react-komposer@1.8.0",
  "_inCache": true,
  "_location": "/react-komposer",
  "_phantomChildren": {},
  "_requested": {
    "raw": "react-komposer@https://registry.npmjs.org/react-komposer/-/react-komposer-1.8.0.tgz",
    "scope": null,
    "escapedName": "react-komposer",
    "name": "react-komposer",
    "rawSpec": "https://registry.npmjs.org/react-komposer/-/react-komposer-1.8.0.tgz",
    "spec": "https://registry.npmjs.org/react-komposer/-/react-komposer-1.8.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/",
    "/mantra-core"
  ],
  "_resolved": "https://registry.npmjs.org/react-komposer/-/react-komposer-1.8.0.tgz",
  "_shasum": "762e78116ef98120257217415b58f5b1d523cb2d",
  "_shrinkwrap": null,
  "_spec": "react-komposer@https://registry.npmjs.org/react-komposer/-/react-komposer-1.8.0.tgz",
  "_where": "/home/rails/production/releases/20170630170906/client",
  "bugs": {
    "url": "https://github.com/kadirahq/react-komposer/issues"
  },
  "dependencies": {
    "babel-runtime": "6.x.x",
    "hoist-non-react-statics": "1.x.x",
    "invariant": "2.x.x",
    "shallowequal": "0.2.x"
  },
  "description": "Compose React containers and feed data into components.",
  "devDependencies": {
    "babel-cli": "6.x.x",
    "babel-core": "6.x.x",
    "babel-eslint": "4.x.x",
    "babel-plugin-transform-runtime": "6.x.x",
    "babel-polyfill": "6.x.x",
    "babel-preset-es2015": "6.x.x",
    "babel-preset-react": "6.x.x",
    "babel-preset-stage-2": "6.x.x",
    "browserify": "12.x.x",
    "chai": "3.x.x",
    "enzyme": "^2.2.0",
    "eslint": "1.7.x",
    "eslint-plugin-babel": "2.x.x",
    "eslint-plugin-react": "3.x.x",
    "exposify": "0.5.x",
    "mocha": "2.x.x",
    "nodemon": "1.7.x",
    "react": "^15.0.0",
    "react-addons-test-utils": "^15.0.0",
    "react-dom": "^15.0.0",
    "rx": "4.x.x",
    "uglifyify": "3.x.x"
  },
  "homepage": "https://github.com/kadirahq/react-komposer#readme",
  "license": "MIT",
  "name": "react-komposer",
  "optionalDependencies": {},
  "options": {
    "mocha": "--require scripts/mocha_runner lib/**/__tests__/**/*.js"
  },
  "peerDependencies": {
    "react": "^0.14.3 || ^15.0.0"
  },
  "react-native": "./dist/index.js",
  "readme": "# react-komposer\n\nLet's compose React containers and feed data into components. <br>\n(supports ReactNative as well)\n\n## TOC\n\n* [Why](#why)\n* [Installation](#installation)\n* [Basic Usage](#basic-usage)\n* [API](#api)\n* [Using with XXX](#using-with-xxx)\n    - [Using with Promises](#using-with-promises)\n    - [Using with Meteor](#using-with-meteor)\n    - [Using with Rx.js Observables](#using-with-rxjs-observables)\n    - [Using with Redux](#using-with-redux)\n* [Extending](#extending)\n* [Caveats](#caveats)\n\n## Why?\n\nLately, in React we tried to avoid states as possible we can and use props to pass data and actions. So, we call these components **Dumb Components** or **UI components.**\n\nAnd there is another layer of components, which knows how to **fetch data**. We call them as **Containers**. Containers usually do things like this:\n\n* Request for data (invoke a subscription or just fetch it).\n* Show a loading screen while the data is fetching.\n* Once data arrives, pass it to the UI component.\n* If there is an error, show it to the user.\n* It may need to refetch or re-subscribe when props changed.\n* It needs to cleanup resources (like subscriptions) when the container is unmounting.\n\nIf you want to do these your self, you have to do a lot of **repetitive tasks**. And this is good place for **human errors**.\n\n**Meet React Komposer**\n\nThat's what we are going to fix with this project. You simply tell it how to get data and clean up resources. Then it'll do the hard work you. This is a universal project and work with **any kind of data source**, whether it's based Promises, Rx.JS observables or even Meteor's Tracker.\n\n## Installation\n\n```\nnpm i --save react-komposer\n```\n\n## Basic Usage\n\nLet's say we need to build a clock. First let's create a component to show the time.\n\n```js\nconst Time = ({time}) => (<div>Time is: {time}</div>);\n```\n\nNow let's define how to fetch data for this:\n\n```js\nconst onPropsChange = (props, onData) => {\n  const handle = setInterval(() => {\n    const time = (new Date()).toString();\n    onData(null, {time});\n  }, 1000);\n\n  const cleanup = () => clearInterval(handle);\n  return cleanup;\n};\n```\n\nOn the above function, we get data for every seconds and send it via `onData`. Additionally, we return a cleanup function from the function to cleanup it's resources.\n\nOkay. Now it's time to create the clock:\n\n```js\nimport { compose } from 'react-komposer';\nconst Clock = compose(onPropsChange)(Time);\n```\n\nThat's it. Now render the clock to the DOM.\n\n```js\nimport ReactDOM from 'react-dom';\nReactDOM.render(<Clock />, document.body);\n```\n\nSee this in live: <https://jsfiddle.net/arunoda/jxse2yw8>\n\n### Additional Benefits\n\nOther than main benefits, now it's super easy to test our UI code. We can easily do it via a set of unit tests.\n\n* For that UI, simply test the plain react component. In this case, `Time` (You can use [enzyme](https://github.com/airbnb/enzyme) for that).\n* Then test `onPropsChange` for different scenarios.\n\n## API\n\nYou can customize the higher order component created by `compose` in few ways. Let's discuss.\n\n### Handling Errors\n\nRather than showing the data, something you need to deal with error. Here's how to use `compose` for that:\n\n```js\nconst onPropsChange = (props, onData) => {\n  // oops some error.\n  onData(new Error('Oops'));\n};\n```\n\nThen error will be rendered to the screen (in the place where component is rendered). You must provide a JavaScript error object.\n\nYou can clear it by passing a some data again like this:\n\n```js\nconst onPropsChange = (props, onData) => {\n  // oops some error.\n  onData(new Error('Oops'));\n\n  setTimeout(() => {\n    onData(null, {time: Date.now()});\n  }, 5000);\n};\n```\n\n### Detect props changes\n\nSome times can use the props to custom our data fetching logic. Here's how to do it.\n\n```js\nconst onPropsChange = (props, onData) => {\n  const handle = setInterval(() => {\n    const time = (props.timestamp)? Date.now() : (new Date()).toString();\n    onData(null, {time});\n  }, 1000);\n\n  const cleanup = () => clearInterval(handle);\n  return cleanup;\n};\n```\n\nHere we are asking to make the Clock to display timestamp instead of a the Date string. See:\n\n```js\nReactDOM.render((\n  <div>\n    <Clock timestamp={true}/>\n    <Clock />\n  </div>\n), document.body);\n```\n\nSee this in live: <https://jsfiddle.net/arunoda/7qy1mxc7/>\n\n### Change the Loading Component\n\n```js\nconst MyLoading = () => (<div>Hmm...</div>);\nconst Clock = compose(onPropsChange, MyLoading)(Time);\n```\n\n### Change the Error Component\n\n```js\nconst MyError = ({error}) => (<div>Error: {error.message}</div>);\nconst Clock = compose(onPropsChange, null, MyError)(Time);\n```\n\n### Compose Multiple Containers\n\nSometimes, we need to compose multiple containers at once, in order to use different data sources. Checkout following examples:\n\n```js\nconst Clock = composeWithObservable(composerFn1)(Time);\nconst MeteorClock = composeWithTracker(composerFn2)(Clock);\n\nexport default MeteorClock;\n```\n\nFor the above case, we've a utility called `composeAll` to make our life easier. See how to use it:\n\n```js\nexport default composeAll(\n  composeWithObservable(composerFn1),\n  composeWithTracker(composerFn2)\n)(Time)\n```\n\n### Pure Containers\n\n`react-komposer` checks the purity of payload, error and props and avoid unnecessary render function calls. That means we've implemented `shouldComponentUpdate` lifecycle hook and follows something similar to React's [shallowCompare](https://facebook.github.io/react/docs/shallow-compare.html).\n\nIf you need to turn this functionality you can turn it off like this:\n\n```js\n// You can use `composeWithPromise` or any other compose APIs\n// instead of `compose`.\nconst Clock = compose(onPropsChange, null, null, {pure: false})(Time);\n```\n\n### Disable functionality\n\nSometimes, when testing we may need to disable the functionality of React Komposer. If needed, we can do it like this:\n\n```js\nimport { disable } from 'react-komposer';\ndisable();\n```\n\nYou need to do this, before composing any containers. After that, the composed container will render nothing.\n\n> This is pretty useful when used with [React Storybook](https://github.com/kadirahq/react-storybook).\n\nYou can also revert this behaviour with:\n\n```js\ndisable(false);\n```\n\n> Anyway, you need to create containers again.\n\n\n## Using with XXX\n\n### Using with Promises\n\nFor this, you can use the `composeWithPromise` instead of `compose`.\n\n```js\nimport {composeWithPromise} from 'react-komposer'\n\n// Create a component to display Time\nconst Time = ({time}) => (<div>{time}</div>);\n\n// Assume this get's the time from the Server\nconst getServerTime = () => {\n  return new Promise((resolve) => {\n    const time = new Date().toString();\n    setTimeout(() => resolve({time}), 2000);\n  });\n};\n\n// Create the composer function and tell how to fetch data\nconst composerFunction = (props) => {\n  return getServerTime();\n};\n\n// Compose the container\nconst Clock = composeWithPromise(composerFunction)(Time, Loading);\n\n// Render the container\nReactDOM.render(<Clock />, document.getElementById('react-root'));\n```\n\nSee this live: <https://jsfiddle.net/arunoda/8wgeLexy/>\n\n### Using with Meteor\n\nFor that you need to use `composeWithTracker` method instead of `compose`. Then you can watch any Reactive data inside that.\n\n```js\nimport {composeWithTracker} from 'react-komposer';\nimport PostList from '../components/post_list.jsx';\n\nfunction composer(props, onData) {\n  if (Meteor.subscribe('posts').ready()) {\n    const posts = Posts.find({}, {sort: {_id: 1}}).fetch();\n    onData(null, {posts});\n  };\n};\n\nexport default composeWithTracker(composer)(PostList);\n```\n\nIn addition to above, you can also return a cleanup function from the composer function. See following example:\n\n```js\nimport {composeWithTracker} from 'react-komposer';\nimport PostList from '../components/post_list.jsx';\n\nconst composerFunction = (props, onData) => {\n  // tracker related code\n  return () => {console.log('Container disposed!');}\n};\n\n// Note the use of composeWithTracker\nconst Container = composeWithTracker(composerFunction)(PostList);\n```\n\nFor more information, refer this article: [Using Meteor Data and React with Meteor 1.3](https://voice.kadira.io/using-meteor-data-and-react-with-meteor-1-3-13cb0935dedb)\n\n\n### Using with Rx.js Observables\n\n```js\nimport {composeWithObservable} from 'react-komposer'\n\n// Create a component to display Time\nconst Time = ({time}) => (<div>{time}</div>);\n\nconst now = Rx.Observable.interval(1000)\n  .map(() => ({time: new Date().toString()}));\n\n// Create the composer function and tell how to fetch data\nconst composerFunction = (props) => now;\n\n// Compose the container\nconst Clock = composeWithObservable(composerFunction)(Time);\n\n// Render the container\nReactDOM.render(<Clock />, document.getElementById('react-root'));\n```\n\nTry this live: <https://jsfiddle.net/arunoda/Lsdekh4y/>\n\n### Using with Redux\n\n```js\n\nconst defaultState = {time: new Date().toString()};\nconst store = Redux.createStore((state = defaultState, action) => {\n  switch(action.type) {\n    case 'UPDATE_TIME':\n      return {\n        ...state,\n        time: action.time\n      };\n    default:\n      return state;\n  }\n});\n\nsetInterval(() => {\n  store.dispatch({\n    type: 'UPDATE_TIME',\n    time: new Date().toString()\n  });\n}, 1000);\n\n\nconst Time = ({time}) => (<div><b>Time is</b>: {time}</div>);\n\nconst onPropsChange = (props, onData) => {\n  onData(null, {time: store.getState().time});\n  return store.subscribe(() => {\n    const {time} = store.getState();\n    onData(null, {time})\n  });\n};\n\nconst Clock = compose(onPropsChange)(Time);\n\nReactDOM.render(<Clock />, document.getElementById('react'))\n```\n\nTry this live: <https://jsfiddle.net/arunoda/wm6romh4/>\n\n## Extending\n\nContainers built by React Komposer are, still, technically just React components. It means that they can be extended in the same way you would extend any other component. Checkout following examples:\n\n\n```js\nconst Tick = compose(onPropsChange)(Time);\nclass Clock extends Tick {\n  componentDidMount() {\n    console.log('Clock started');\n\n    return super();\n  }\n  componentWillUnmount() {\n    console.log('Clock stopped');\n\n    return super();\n  }\n};\nClock.displayName = 'ClockContainer';\n\nexport default Clock;\n```\n\nRemember to call `super` when overriding methods already defined in the container.\n\n\n## Caveats\n\n**SSR**\n\nIn the server, we won't be able to cleanup resources even if you return the cleanup function. That's because, there is no functionality to detect component unmount in the server. So, make sure to handle the cleanup logic by yourself in the **server**.\n\n**Composer Rerun on any prop change**\n\nRight now, composer function is running again for any prop change. We can fix this by watching props and decide which prop has been changed. See: [#4](https://github.com/kadirahq/react-komposer/issues/4)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/kadirahq/react-komposer.git"
  },
  "scripts": {
    "lint": "eslint ./lib",
    "lintfix": "eslint ./lib --fix",
    "prepublish": ". ./scripts/prepublish.sh",
    "test": "npm run lint && npm run testonly",
    "test-watch": "npm run testonly -- --watch",
    "testonly": "mocha $npm_package_options_mocha"
  },
  "version": "1.8.0"
}
